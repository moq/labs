'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Imports Moq.Sdk
Imports Stunts
Imports System.Threading
Imports System.Collections.ObjectModel
Imports System.Reflection
Imports System.Runtime.CompilerServices
Imports Sample

Public Class FooMock
    Inherits CalculatorBase
    Implements IStunt, IMocked

    ReadOnly pipeline As BehaviorPipeline = New BehaviorPipeline()

    <CompilerGenerated>
    ReadOnly Property Behaviors As ObservableCollection(Of IStuntBehavior) Implements IStunt.Behaviors
        Get
            Return pipeline.Behaviors
        End Get
    End Property

    Dim _mock As IMock

    <CompilerGenerated>
    ReadOnly Property Mock As IMock Implements IMocked.Mock
        Get
            Return LazyInitializer.EnsureInitialized(_mock, (Function() New DefaultMock(Me)))
        End Get
    End Property

    <CompilerGenerated>
    Public Overrides ReadOnly Property IsOn As Boolean
        Get
            Return pipeline.Execute(Of Boolean
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
        End Get
    End Property

    <CompilerGenerated>
    Public Overrides Property Mode As CalculatorMode
        Get
            Return pipeline.Execute(Of CalculatorMode
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
        End Get
        Set(value As CalculatorMode)
            pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), value))
        End Set
    End Property

    <CompilerGenerated>
    Default Public Overrides Property Item(name As String) As Integer?
        Get
            Return pipeline.Execute(Of Integer?
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name))
        End Get
        Set(value As Integer?)
            pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name, value))
        End Set
    End Property

    <CompilerGenerated>
    Public Overrides ReadOnly Property Memory As ICalculatorMemory
        Get
            Return pipeline.Execute(Of ICalculatorMemory
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
        End Get
    End Property

    <CompilerGenerated>
    Public Overrides Function ToString() As String
        Return pipeline.Execute(Of String
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
    End Function

    <CompilerGenerated>
    Public Overrides Function Equals(obj As Object) As Boolean
        Return pipeline.Execute(Of Boolean
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), obj))
    End Function

    <CompilerGenerated>
    Public Overrides Function GetHashCode() As Integer
        Return pipeline.Execute(Of Integer
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
    End Function

    <CompilerGenerated>
    Public Overrides Function Add(x As Integer, y As Integer) As Integer
        Return pipeline.Execute(Of Integer
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), x, y))
    End Function

    <CompilerGenerated>
    Public Overrides Function Add(x As Integer, y As Integer, z As Integer) As Integer
        Return pipeline.Execute(Of Integer
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), x, y, z))
    End Function

    <CompilerGenerated>
    Public Overrides Function TryAdd(ByRef x As Integer, ByRef y As Integer, ByRef z As Integer) As Boolean
        Dim returns As IMethodReturn = pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), x, y, z))
        x = DirectCast(returns.Outputs("x"), Integer)
        y = DirectCast(returns.Outputs("y"), Integer)
        z = DirectCast(returns.Outputs("z"), Integer)
        Return returns.ReturnValue
    End Function

    <CompilerGenerated>
    Public Overrides Sub TurnOn()
        pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod()))
    End Sub

    <CompilerGenerated>
    Public Overrides Sub Store(name As String, value As Integer)
        pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name, value))
    End Sub

    <CompilerGenerated>
    Public Overrides Function Recall(name As String) As Integer?
        Return pipeline.Execute(Of Integer?
        )(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name))
    End Function

    <CompilerGenerated>
    Public Overrides Sub Clear(name As String)
        pipeline.Execute(New MethodInvocation(Me, MethodBase.GetCurrentMethod(), name))
    End Sub
End Class
